#LyX 2.0.0beta3 created this file. For more info see http://www.lyx.org/
\lyxformat 410
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{lhs2tex}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
DGG: Datatype-generic Generator
\end_layout

\begin_layout Author
JurriÃ«n Stutterheim
\end_layout

\begin_layout Abstract
Libraries for datatype-generic programming (DGP) often follow a similar
 pattern when generating boilerplate code for converting data types to and
 from their generic representations.
 A data type is parsed and analysed and code is generated, often using Template
 Haskell.
 While this approach is convenient for the end-user of the DGP library,
 it is not so for the library developer.
 Parsing and analysing data types is done very similarly across different
 DGP libraries, effectively duplicating work.
 In addition, the Template Haskell implementation frequently changes with
 new GHC releases, causing library developers a lot of work to maintain
 compatibility with different GHC versions.
 Also, debugging Template Haskell code can be hard, since it is only visible
 using GHCi.
 Finally, Template Haskell is only available on GHC, making the libraries
 inconvenient to use on other compilers.
 This paper presents a solution, called 
\family sans
DGG
\family default
, which solves the aforementioned problems by parsing data types to a custom
 DSL, by abstracting from Template Haskell using the 
\family sans
Derive
\family default
 library and by offering a command-line tool as an alternative to Template
 Haskell for use in development or with other compilers.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Datatype generic programming (DGP) libraries commonly offer the ability
 to generate the code required to obtain generic representations of data
 types and to operate on these representations.
 Generating this code is generally done at compile time using Template Haskell
\begin_inset CommandInset citation
LatexCommand cite
key "Sheard:2002p631"

\end_inset

.
 When the Template Haskell code is executed during compilation, a function
 from the DGP library parses the data type passed to it and generates code
 based on the information extracted from the data type.
 While this approach is convenient for most end-users, it poses problems
 for library developers.
 The process of parsing data types and extracting information is largely
 similar across different DGP libraries.
 However, currently each library has its own mechanism for obtaining this
 information, duplicating a lot of work.
 Other problems arise from the use of Template Haskell itself.
 Currently, Template Haskell is only supported by GHC, making the libraries
 inconvenient to use in combination with other compilers.
 In addition, the Template Haskell implementation tends to change frequently
 with new GHC releases, causing library writers extra work to maintain compatibi
lity with different Template Haskell versions.
 Finally, developing Template Haskell code is hard, because the generated
 code is hard to debug.
\end_layout

\begin_layout Standard

\family sans
DGG
\family default
 aims to provide a solution to the aforementioned problems.
 It does so by abstracting over the process of generating generic code by
 using the 
\family sans
Derive
\family default

\begin_inset CommandInset citation
LatexCommand cite
key "Mitchell:2009p599"

\end_inset

 and 
\family sans
haskell-src-exts
\family default
 libraries.
 It provides the ability to parse data types and convert them to a simple
 DSL which captures all information required for generating generic code
 in a concise form.
 Individual DGP libraries can then provide an adapter which translates this
 DSL into the generic code required by the library.
\end_layout

\begin_layout Standard
In addition to providing Template Haskell support in the way one might expect,
 
\family sans
DGG
\family default
 also offers a command-line tool as a solutions to some of the Template
 Haskell drawbacks.
 It is able to generate a module containing the generic code, which can
 be outputted to file or standard output.
 This approach offers two advantages: it is compiler independent and it
 allows library writers to more easily debug their code.
 The downside of this approach is that the tool has to be invoked whenever
 the data types change.
\end_layout

\begin_layout Standard
By using 
\family sans
Derive
\family default
 to abstract from Template Haskell, any change in Template Haskell only
 needs to be captured by the 
\family sans
Derive
\family default
 library, making it easier for 
\family sans
DGG
\family default
 and DGP library writers to offer support for multiple Template Haskell
 versions.
\end_layout

\begin_layout Standard
The rest of the paper is structured as follows.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:DGG-DSL"

\end_inset

 presents the 
\family sans
DGG
\family default
 DSL upon which the rest of the library is built.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Command-line-Support"

\end_inset

 introduces the 
\family sans
DGG
\family default
 command-line facilities, after which section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Template-Haskell-Support"

\end_inset

 will show the Template Haskell support.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Extending-DGG"

\end_inset

 will detail what DGP library developers need to do to add support for their
 library to 
\family sans
DGG
\family default
.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Developing-DGG"

\end_inset

 reflects on the development process of the library.
 Finally, section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Future-Work"

\end_inset

 will discuss current challenges and future work, after which section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Conclusion"

\end_inset

 concludes.
\end_layout

\begin_layout Section
DGG DSL
\begin_inset CommandInset label
LatexCommand label
name "sec:DGG-DSL"

\end_inset


\end_layout

\begin_layout Standard
DGP libraries generally offer an ability to generate generic code for data
 types.
 In order to generate this code, a data type needs to be parsed, various
 properties of the data type need to be established and all information
 required to generate the generic code need to be extracted.
 This process is very similar across different DGP libraries.
 
\family sans
DGG
\family default
 offers a simple DSL which captures all required information about data
 types in a consice format and parsing facilities to parse data types into
 this DSL.
 DGP library writers can then proceed to generate generic code from this
 DSL, eliminating the need to do data type parsing and analysis for every
 individual DGP library.
 
\end_layout

\begin_layout Standard
Presented in Algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:DGG-DSL-data"

\end_inset

 are the top-level data types of the 
\family sans
DGG
\family default
 DSL.
 The 
\family typewriter
TCInfo
\family default
 data type contains information for the type constructor, while the 
\family typewriter
DCInfo
\family default
 data type contains information for the data constructor.
 Properties such as the type constructor arity can be derived from the available
 information.
 Several smaller data types have been omitted for brievety.
 The 
\family typewriter
DCVar
\family default
 and 
\family typewriter
TCVar
\family default
 types contain information such as the variable's name, kind and whether
 or not the variable is universally quantified.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template LHS
	filename data-tcvc.lhs

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:DGG-DSL-data"

\end_inset


\family sans
DGG
\family default
 DSL data types
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
From the information in the data types other useful information can be derived,
 which can then be used to determine if specific DGP libraries support the
 data type in question or not.
 A data type is analysed, after which various properties are established.
 These properties are based on those used in the comparison in 
\begin_inset CommandInset citation
LatexCommand cite
key "Rodriguez:2008p606"

\end_inset

, with some additional properties added.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Universe-data-type"

\end_inset

 shows the data type which is used to classify support properties.
 The first nine properties are described in the aforementioned paper and
 will therefor not be explained here.
 The last one indicates support for mutually recursive data types.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template LHS
	filename data-univ.lhs

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Universe-data-type"

\end_inset

Universe data type
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Template Haskell Support
\begin_inset CommandInset label
LatexCommand label
name "sec:Template-Haskell-Support"

\end_inset


\end_layout

\begin_layout Standard
End-users of DGP libraries will often want to have the generic code generated
 for them automatically during compile-time.
 
\family sans
DGG
\family default
 uses the 
\family sans
Derive
\family default
 library to offer end-users the ability to generate the generic representation
 types using Template Haskell.
 The main advantage of this approach is that changing the programmer's data
 types does require the code to be regenerated, since this happens automatically
 at compile-time.
\end_layout

\begin_layout Standard
Using 
\family sans
Derive
\family default
 to generate code is simple.
 Each 
\family sans
DGG
\family default
 adapter offers a function called 
\family typewriter
derive*
\family default
, where the 
\family typewriter
*
\family default
 is the name of the DGP library in question.
 Calling the 
\family typewriter
derive
\family default
 function with Template Haskell and passing the 
\family typewriter
derive*
\family default
 function and the data type for which generic code needs to be generated
 is all that's needed.
 The following snippet shows typical usage.
\end_layout

\begin_layout Standard
\begin_inset External
	template LHS
	filename th.lhs

\end_inset


\end_layout

\begin_layout Standard
Internally the 
\family typewriter
derive*
\family default
 function makes use of the same function the command-line tool uses to generate
 the generic code.
 Library writers only have to implement the generator code once.
 More on this in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Extending-DGG"

\end_inset

.
\end_layout

\begin_layout Section
Command-line Support
\begin_inset CommandInset label
LatexCommand label
name "sec:Command-line-Support"

\end_inset


\end_layout

\begin_layout Standard

\family sans
DGG
\family default
 offers a command-line infrastructure to generate generic code using 
\family sans
DGG
\family default
 as a standalone application.
 This approach offers two advantages.
 Firstly, library developers can more easily debug their generic code, since
 the generated code is either outputted to the standard output or is written
 to file.
 There is no more need for diving into GHCi with the 
\family typewriter
-ddump-splices
\family default
 flag.
 Secondly, developers who are not using GHC and have no access to Template
 Haskell can still benefit from generated generic code.
\end_layout

\begin_layout Standard
Invoking the tool causes a complete module to be generated.
 If written to a file, this module can directly be imported from other code.
 By default, generic code will be generated for all data types found in
 the input file.
 Future iterations of the tool will allow for cherry-picking the data types
 for which code needs to be generated.
\end_layout

\begin_layout Standard
At least two arguments need to be passed to the tool for it to work: the
 input file and the name of the DGP library.
 The former can be specified by the short 
\family typewriter
-i
\family default
 or the longer 
\family typewriter
--input
\family default
 flag.
 The latter can be specified by the 
\family typewriter
-a
\family default
 or 
\family typewriter
--adapter
\family default
 flag.
 The following snippet generates generic code for 
\family sans
EMGM
\family default
 for the data types found in the file 
\family typewriter
DataTypes.hs
\family default
 and writes the generated code to the file 
\family typewriter
Generated.hs
\family default
 using the 
\family typewriter
-o
\family default
 (for 
\family typewriter
--output
\family default
) flag.
\end_layout

\begin_layout LyX-Code
dgg -i 
\begin_inset Quotes eld
\end_inset

DataTypes.hs
\begin_inset Quotes erd
\end_inset

 -a 
\begin_inset Quotes eld
\end_inset

EMGM
\begin_inset Quotes erd
\end_inset

 -o 
\begin_inset Quotes eld
\end_inset

Generated.hs
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In case the output flag is left unspecified, the generated code is printed
 to standard output.
 The code could then be captured using the standard Unix piping mechanisms.
 The following snippet is equivalent to the previous one.
\end_layout

\begin_layout LyX-Code
dgg -i 
\begin_inset Quotes eld
\end_inset

DataTypes.hs
\begin_inset Quotes erd
\end_inset

 -a 
\begin_inset Quotes eld
\end_inset

EMGM
\begin_inset Quotes erd
\end_inset

 > 
\begin_inset Quotes eld
\end_inset

Generated.hs
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
DGG Architecture
\end_layout

\begin_layout Standard
This section will give a broad overview of the 
\family sans
DGG
\family default
 architecture.
 Figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:High-level-overview-of"

\end_inset

 presents a high-level overview of the various components in the library
 and how they related to one another.
 It neatly shows how various concerns are separated so that the library
 can be easily extended.
\end_layout

\begin_layout Standard
As the figure shows, 
\family sans
DGG
\family default
 accepts two sources for input; a Haskell source file from the command-line
 utility or a data type passed via Template Haskell.
 Each data type passed to it is first parsed by the 
\family sans
haskell-src-exts
\family default
 parser, which produces an abstract syntax tree (AST) with information about
 the data type in question.
 This AST is converted into the 
\family sans
DGG
\family default
 DSL, which in turn is consumed by the adapter specified in either the command-l
ine call or the Template Haskell call to produce a new 
\family sans
haskell-src-exts
\family default
 AST.
 This new AST contains the library specific code that is to be generated.
 In case the command-line tool is used, the 
\family sans
haskell-src-exts
\family default
 pretty printer is used to either write the generated code to standard output
 or to file.
 In case of Template Haskell, the AST is passed to 
\family sans
Derive
\family default
 which then instructs Template Haskell to output the generated code.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename dgg.dot
	width 200pt

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:High-level-overview-of"

\end_inset

High-level overview of 
\family sans
DGG
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Extending DGG
\begin_inset CommandInset label
LatexCommand label
name "sec:Extending-DGG"

\end_inset


\end_layout

\begin_layout Standard
Adding support for new generic programming libraries is straight-forward.
 First, a new adapter module is created in the 
\family typewriter
DGG.Adapter
\family default
 namespace.
 The convention is that this new adapter has the same name as the generic
 programming library.
 E.g., if the DGP library is called 
\family typewriter
FooGP
\family default
, then the adapter module will be called 
\family typewriter
DGG.Adapter.FooGP
\family default
.
 To make the required types and several convenience functions available,
 the 
\family typewriter
DGG.AdapterAbstract
\family default
 module needs to be imported.
\end_layout

\begin_layout Standard
An adapter module exports four functions, where the 
\family typewriter
*
\family default
 is replaced with the name of the library:
\end_layout

\begin_layout Standard
\begin_inset External
	template LHS
	filename adapterInterface.lhs

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
imports*
\family default
 function creates a list of 
\family typewriter
ImportDecl
\family default
s specifying the modules required to use the DGP library.
 This information is used by the 
\family sans
DGG
\family default
 command-line tool to generate a module which can be compiled without further
 editing.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
derive*
\family default
 function is used to generate generic code for individual data types using
 Template Haskell.
 Its definition is very simple.
 It calls the 
\family typewriter
deriveLib
\family default
 function from the 
\family typewriter
AdapterAbstract
\family default
 module, passing the DGP library name and the 
\family typewriter
make*
\family default
 function, as is shown in the following code snippet.
\end_layout

\begin_layout Standard
\begin_inset External
	template LHS
	filename derive.lhs

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
make*
\family default
 function is responsible for generating the generic code for a single data
 type.
 It takes a 
\family typewriter
TCInfo
\family default
 value and produces a 
\family typewriter
Decl
\family default
.
 This 
\family typewriter
Decl
\family default
 can then be used by either the 
\family typewriter
derive*
\family default
 function or by the 
\family sans
DGG
\family default
 command-line tool.
\end_layout

\begin_layout Standard
Finally, the 
\family typewriter
isSupp*
\family default
 function specifies which data type properties are supported by the DGP
 library, e.g., does the library support GADTs or mutually recursive data
 types?
\end_layout

\begin_layout Standard
To add support for the new DGP library to the command-line tool, the 
\family typewriter
Main
\family default
 module needs to be modified.
 A new 
\family typewriter
Adapter
\family default
 value needs to be added to the list in the 
\family typewriter
adapters
\family default
 function, paired with the DGP library name in lower case.
 This new Adapter value contains references to the 
\family typewriter
make*
\family default
, 
\family typewriter
isSupp*
\family default
 and 
\family typewriter
imports*
\family default
 functions of the new adapter.
 For our 
\family typewriter
FooGP
\family default
 library, the new pair would look as follows:
\end_layout

\begin_layout Standard
\begin_inset External
	template LHS
	filename adaptersEntry.lhs

\end_inset


\end_layout

\begin_layout Section
Developing DGG
\begin_inset CommandInset label
LatexCommand label
name "sec:Developing-DGG"

\end_inset


\end_layout

\begin_layout Standard
In developing 
\family sans
DGG
\family default
, several requirements needed to be met.
 As stated before, the final product needs to be used via both Template
 Haskell and the command line.
 In addition, the library needed to be easily extendible with with support
 for new DGP libraries.
 Since the Template Haskell support and the command-line tool share a lot
 of functionality and because the library needs to be extendible, the library
 needed to be designed modularly in such a way that individual adapters
 are self-contained and expose a simple API.
 Due to this approach, the code reuse for the various purposes is excellent.
 No functionality needs to be duplicated inside the adapters.
\end_layout

\begin_layout Standard

\family sans
DGG
\family default
 makes use of 
\family sans
Derive
\family default
's ability to generate Template Haskell code based on 
\family typewriter
Decl
\family default
s from 
\family sans
haskell-src-exts
\family default
, using the 
\family typewriter
derivationCustom
\family default
 function.
 A higher-order function 
\family typewriter
deriveLib
\family default
 accepts a code generator function which is used to generate DGP library
 specific code.
 While the code for this feature is small and simple, it brings a powerful
 feature to 
\family sans
DGG
\family default
 which optimally uses the rest of the infrastructure.
 A major advantage of using 
\family sans
Derive
\family default
 for this is that 
\family sans
DGG
\family default
 does not have a direct dependency on Template Haskell either, but instead
 relies on 
\family sans
Derive
\family default
 to interface with Template Haskell.
\end_layout

\begin_layout Standard
Developing the individual adapters for 
\family sans
EMGM
\family default
 and 
\family sans
SYB
\family default
 posed a challenge.
 In this process, the knowledge obtained from the course in Generic Programming
 proved to be invaluable.
 For each of the adapters the approach taken was as follows.
 First, generic representations were created either manually or using existing
 generic code generation techniques.
 For 
\family sans
SYB
\family default
 this was adding 
\family typewriter
deriving (Data, Typeable)
\family default
 to the data types and running GHCi with the 
\family typewriter
-ddump-deriv
\family default
 flag to obtain the generated code on which the generated code from the
 adapter could be based.
 Doing the same with 
\family sans
EMGM
\family default
 proved a bit more challenging, since Template Haskell support for 
\family sans
EMGM
\family default
 0.3.1 is broken on GHC 6.12 and 7.0 and the latest development version lacks
 Template Haskell support.
 Instead, manual definitions from the exercises from the Generic Programming
 course were used instead.
 With the code available in a separate module, the parsing facilities from
 
\family sans
haskell-src-exts
\family default
 could be used to get a representation of the generic code in its syntax.
 This representation could then be made dynamic so that the code could be
 generated for arbitrary data types.
 The downside to this approach is that the resulting adapters do not necessarily
 support all the usecases the original libraries support.
\end_layout

\begin_layout Standard
Another approach to constructing the adapters could have been to analyse
 the existing Template Haskell code from the DGP libraries and modify that
 to work with the 
\family sans
DGG
\family default
 data types and 
\family sans
haskell-src-exts
\family default
.
 The advantage to this approach would be that the new adapter would support
 the same use cases as the library code.
 However, since the Template Haskell code was significantly different from
 the manually created adapter code and the code would have to be adapted
 to work with the 
\family sans
DGG
\family default
 data types, this approach seemed to be at least as much work as writing
 the adapters from scratch.
\end_layout

\begin_layout Section
Future Work
\begin_inset CommandInset label
LatexCommand label
name "sec:Future-Work"

\end_inset


\end_layout

\begin_layout Standard
Although 
\family sans
DGG
\family default
's main features can already be demonstrated, it is still very much a work
 in progress.
 As such, plenty of work still remains to be done.
\end_layout

\begin_layout Standard
First and foremost, the adapters that are currently available need to be
 improved so that they support the same data types as the existing DGP libraries.
 Only then can 
\family sans
DGG
\family default
 be considered an alternative to existing solutions.
 Several other current issues are directly related to this issue.
\end_layout

\begin_layout Standard
Currently 
\family sans
DGG
\family default
 only supports parsing data declarations.
 In the future, it must support other types as well, such as type synonyms
 and GADTs.
 Type synonyms would then first be resolved, after which generic code would
 be generated based on the original data type.
 
\end_layout

\begin_layout Standard
After support for various types has been added, an improved algorithm for
 determining type support must be added.
 The current approach allows only normal data types and disallows any other
 types.
 However, it is desirable to analyse the data types for specific properties,
 such as those described by Rodriguez et al.
\begin_inset CommandInset citation
LatexCommand cite
key "Rodriguez:2008p606"

\end_inset

.
 For example, some DGP libraries support nested types, while others do not.
 In case a data type is not supported and Template Haskell is used, an error
 should be raised and compilation should be aborted.
 When using the command-line tool, the generated code could just contain
 comments with support notices.
\end_layout

\begin_layout Standard
In the current implementation, kind analysis is wrongly implemented.
 While the current approach of counting the number of type variables works
 fine for the 
\family sans
SYB
\family default
 adapter, it fails to produce the right code for more complex kinds.
 Proper analysis of the kind information stored in the 
\family sans
DGG
\family default
 data types can solve this problem.
 Both the 
\family sans
EMGM
\family default
 and 
\family sans
SYB
\family default
 adapters currently suffer from this problem.
\end_layout

\begin_layout Standard
Wrapping up, infix constructors and operator associativity are not currently
 supported.
 Other work that is left to be done is improving the command-line argument
 parsing and adding support for more popular DGP libraries.
\end_layout

\begin_layout Section
Conclusion
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
Using 
\family sans
DGG
\family default
, one is able to generate generic code for custom data types using either
 the 
\family sans
DGG
\family default
 command-line tool or Template Haskell.
 The command-line tool offers convenience for DGP library developers, while
 the Template Haskell support offers convenience to the end-users of those
 libraries.
\end_layout

\begin_layout Standard
Writing adapters for 
\family sans
DGG
\family default
 instead of Template Haskell directly also frees DGP library developers
 from a direct dependency on Template Haskell, which normally requires them
 to modify library code on each new Template Haskell release.
\end_layout

\begin_layout Standard
While the 
\family sans
DGG
\family default
 version presented in this paper still requires significant work, a working
 proof of concept which shows its benefits is already available.
 Continued development can make 
\family sans
DGG
\family default
 a viable solution to DGP library developers and their end-users.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Bibliography"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
